using System.Collections.Generic;
using UnityEngine;
using UnityEditor;

public class AutoTerrainGeneratorTool : EditorWindow
{
    private GameObject parent; // 생성할 프리팹의 부모
    private GameObject prefab; // 생성할 프리팹
    private Vector3 startPosition = Vector3.zero; // 시작 위치
    
    private Vector2Int maxRange = new Vector2Int(20,20);
    private Vector2 range;
    
    private Texture2D heightMap;
    
    [MenuItem("Tools/Auto Terrain Generate Tool")]
    public static void ShowWindow()
    {
        GetWindow<AutoTerrainGeneratorTool>("Auto Terrain Generate Tool");
    }

    private void OnGUI()
    {
        //https://github.com/agagtmdtlr/Flower/issues/7
        GUILayout.Label("게임 오브젝트 자동 배치", EditorStyles.boldLabel);
        
        parent = (GameObject)EditorGUILayout.ObjectField("부모 오브젝트", parent, typeof(GameObject), true);
        prefab = (GameObject)EditorGUILayout.ObjectField("프리팹:", prefab, typeof(GameObject), false);
        startPosition = EditorGUILayout.Vector3Field("시작 위치:", startPosition);
        maxRange = EditorGUILayout.Vector2IntField("최대 범위", maxRange);
        range = maxRange;
        
        heightMap = EditorGUILayout.ObjectField("높이 텍스처", heightMap, typeof(Texture2D), false) as Texture2D;

        if (GUILayout.Button("생성 및 배치"))
        {
            CreateAndPlaceObjects();
        }
    }

    private void ClearTerrain()
    {
        List<GameObject> childrensToDestroy = new List<GameObject>();
        for (int i = 0; i < parent.transform.childCount; i++)
        {
            childrensToDestroy.Add(parent.transform.GetChild(i).gameObject);
        }
        foreach (var children in childrensToDestroy)
        {
            DestroyImmediate(children);
        }
        childrensToDestroy.Clear();
    }

    private Vector3 tileSize;
    private Vector3 pivotOffset;
    private Vector3 mapSize;
    
    private void CreateAndPlaceObjects()
    {
        if (parent == null)
        {
            Debug.LogError("부모를 설정해주세요!");
            return;
        }
        
        if (prefab == null)
        {
            Debug.LogError("프리팹을 설정해주세요!");
            return;
        }

        ClearTerrain();

        var meshFilter = prefab.GetComponent<MeshFilter>();
        var mesh = meshFilter.sharedMesh;
        
        var bounds = mesh.bounds;
        tileSize = bounds.extents * 2.0f;
        mapSize = Vector3.zero;
        
        mapSize.x = tileSize.x * range.x;
        mapSize.z = tileSize.z * range.y;
        mapSize.y = 100;

        pivotOffset = Vector3.zero;// bounds.extents;
        
        for (int x = 0; x < maxRange.x; x++)
        {
            for (int y = 0; y < maxRange.y; y++)
            {
                Vector3 position = startPosition + new Vector3(x * tileSize.x, 0,  y * tileSize.z); // 간격을 두고 생성
                position += pivotOffset;

                GameObject obj = Instantiate(prefab, position, Quaternion.identity);
                obj.transform.SetParent(parent.transform);
                obj.name = $"AutoGenerated_{x}_{y}"; // 이름 설정
                
                CreateTerrainMesh( x, y , obj);
            }
        }
    }
    
    void CreateTerrainMesh(int x, int y, GameObject terrain)
    {
        var meshFilter = terrain.GetComponent<MeshFilter>();
        var meshCollider = terrain.GetComponent<MeshCollider>();
        var originalMesh = meshFilter.sharedMesh;

        // 새로운 Mesh 생성
        Mesh newMesh = new Mesh();

        // 기존 Mesh의 데이터 복사
        newMesh.vertices = originalMesh.vertices;
        newMesh.triangles = originalMesh.triangles;
        newMesh.normals = originalMesh.normals;
        
        List<Vector3> vertices = new List<Vector3>();
        originalMesh.GetVertices(vertices);
        var pixels = heightMap.GetPixels();
        for (int i = 0; i < vertices.Count; i++)
        {
            var wp = terrain.transform.TransformPoint(vertices[i]);
            
            
            Vector2 uv = new Vector2(wp.x / mapSize.x , wp.z / mapSize.z);
            Color pixel = heightMap.GetPixelBilinear(uv.x , uv.y);

            var vector3 = vertices[i];
            vector3.y += pixel.r * 500f; // 높이 조정
            vertices[i] = vector3;
        }


        // SubMesh 데이터 복사
        newMesh.subMeshCount = originalMesh.subMeshCount;
        for (int i = 0; i < originalMesh.subMeshCount; i++)
        {
            newMesh.SetIndices(originalMesh.GetIndices(i), originalMesh.GetTopology(i), i);
        }
        
        newMesh.SetVertices(vertices);
        
        // Bounds 및 기타 데이터 갱신
        newMesh.RecalculateBounds();
        newMesh.RecalculateNormals();
        newMesh.bounds.Expand(Vector3.up * 50f);// expand for grass height

        // 새로운 Mesh를 MeshFilter에 설정
        meshFilter.mesh = newMesh;
        
        var assetName = terrain.name + "_Mesh";
        SaveMeshAsset(newMesh, assetName);
        meshCollider.sharedMesh= newMesh;
    }
    
    public void SaveMeshAsset(Mesh mesh, string assetName)
    {
        if (mesh == null)
        {
            Debug.LogError("저장할 Mesh가 없습니다.");
            return;
        }

        // 저장 경로 설정
        string path = $"Assets/01.InGame/Terrain/Level/{assetName}.asset";

        // 에셋 생성
        AssetDatabase.CreateAsset(mesh, path);
        AssetDatabase.SaveAssets();

        Debug.Log($"Mesh가 {path} 경로에 저장되었습니다.");
    }
}

